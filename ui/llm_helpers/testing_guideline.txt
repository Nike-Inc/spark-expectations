1. Introduction to Testing Standards
This document outlines the standard practices for writing unit and integration tests in our React project. It ensures that all developers adhere to the same testing methodologies, promoting maintainable and reliable code.
2. Test Setup
Testing Library: We use React Testing Library and Vitest for testing. Ensure you are familiar with their APIs.
Mocking: Use vi.mock for mocking modules and dependencies.
Utilities: Utilize common utilities from @/ui/test-utils for rendering components in a test environment.

3. Test File Structure
Each test file should follow this basic structure:

import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@test-utils';
import Component from '@/path/to/Component';

describe('Component', () => {
  it('does something expected', () => {
    render(<Component />);
    expect(screen.getByText('expected text')).toBeInTheDocument();
  });
});

4. Component Testing
Example: Testing Header Component
File: @/components/Header/Header.test.tsx
Key Points:
Test that all sub-components are rendered.
Check for the presence of static text and dynamic content.
Example:
it('renders the logo and user menu', () => {
  render(<Header />);
  expect(screen.getByText('LOGO')).toBeInTheDocument();
  expect(screen.getByTestId('user-menu')).toBeInTheDocument();
});

5. Testing Components with Hooks
Example: Testing ReposList Component
File: @/components/Header/ReposList/ReposList.test.tsx
Key Points:
Mock hooks and external data fetching.
Test loading, error, and success states.
Example:
vi.mock('@/api', () => ({
  useRepos: vi.fn(() => ({ data: repos, isLoading: false, error: null })),
}));
it('renders repository list', () => {
  render(<ReposList />);
  expect(screen.getByText('Repo1')).toBeInTheDocument();
});

6. Provider Testing
Example: Testing AuthProvider
File: @/providers/auth-provider/auth-provider.test.tsx
Key Points:
Test context provision.
Mock child components to test context consumption.
Example:
it('provides auth context', () => {
  render(
    <AppProvider>
      <TestConsumer />
    </AppProvider>
  );
  expect(screen.getByText('Token: test-token')).toBeInTheDocument();
});

7. Utility and Shared Functions
File: @/ui/test-utils/index.ts and @/ui/test-utils/render.tsx
Key Points:
Use custom render function for wrapping components with providers.
Example:
import { customRender } from '@/ui/test-utils';
it('uses custom render', () => {
  customRender(<Component />);
  // Additional test logic
});

8. Best Practices
Always clean up mocks and data after each test to prevent leakage between tests.
Prefer user-centric queries (getByRole, getByLabelText) over implementation details like class names or test IDs.
Write tests for both positive and negative scenarios.
Document any complex mocking or setup required for understanding the test logic.
9. Conclusion
This document serves as a guideline for writing consistent and effective tests in our React project. Adhering to these standards will help maintain the quality and reliability of our application as it evolves.
By following this structured approach, your team can ensure that all tests are written in a consistent manner, making the codebase more maintainable and the testing process more efficient.
